## 一、 安装P4（Ubuntu18环境）

官方指南：[p4-guide/README-install-troubleshooting.md at master · jafingerhut/p4-guide (github.com)](https://github.com/jafingerhut/p4-guide/blob/master/bin/README-install-troubleshooting.md)

挂个VPN，直接去这个地址下载预装P4环境的虚拟机就行。

文中说Ubuntu20使用`install-p4dev-v5.sh`安装脚本，Ubuntu18使用`install-p4dev-v4.sh` or `install-p4dev-v6.sh` 。

> [为ubuntu18.04配置P4环境_冲锋吧，少年的博客-CSDN博客](https://blog.csdn.net/m0_61817617/article/details/122296229)

P4 环境被分为多个子模块，需全部正确安装才能正常使用P4，如下图所示。

（其中protobuf 版本使用v3.6.1 `git checkout v3.6.1`，grpc版本使用v1.17.2 `git checkout tags/v1.17.2`）

![img](https://pic4.zhimg.com/80/v2-de972918cf0b1755f0a73a7eafe7bf3f_720w.webp)

准备一个VPN，我用的是clash，让它给ubuntu虚拟机设置代理。见https://zhuanlan.zhihu.com/p/380614384?ivk_sa=1024320u ， 如果使用clash，可以看评论区有简单方法。

这时就需要虚拟机连一个VPN代理，

<img src="https://img-blog.csdnimg.cn/e1b249950f31469097e456f1fd0f42bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNjE4MTc2MTc=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" />



然后就简单了。

- **将p4-utils下载到ubuntu中**

```cobol
git clone https://github.com/nsg-ethz/p4-utils.git
```

- 运行安装脚本

```cobol
cd p4-utils/install-tools
./install-p4-dev.sh > log.txt
```

- 一切顺利最好，不然就去看文首的链接文章。

- 测试一个例程：

``` bash
~/p4-tools/p4-learning/examples/ip_forwarding$ sudo p4run
```

进入mininet，`h1 ping h2` 测试。

此时可能报错，运行`p4run`时提示没有这个命令，运行`sudo python network.py`时提示没有p4utils模块。

使用`pip show p4utils`发现确实没有。说明p4utils没装成功。 `cd ~/p4tools/p4-utils`切到该目录，运行其中的`sudo ./install.sh ，让它单独重新安装一次即可。安装后就能重新测试上面的例程应该就没问题了。

此时P4环境就搭建完了。

**但是**，当我们下载p4 tutorial的例程`git clone https://github.com/p4lang/tutorials.git` 。运行其中任意一个，结果如下所示：

``` bash
ubt@ubt-vm:~/tutorials/exercises/basic$ sudo make
mkdir -p build pcaps logs
p4c-bm2-ss --p4v 16 --p4runtime-files build/basic.p4.p4info.txt -o build/basic.json basic.p4
sudo python3 ../../utils/run_exercise.py -t pod-topo/topology.json -j build/basic.json -b simple_switch_grpc
Traceback (most recent call last):
  File "../../utils/run_exercise.py", line 28, in <module>
    import p4runtime_lib.simple_controller
  File "/home/ubt/tutorials/utils/p4runtime_lib/simple_controller.py", line 24, in <module>
    from . import bmv2, helper
  File "/home/ubt/tutorials/utils/p4runtime_lib/bmv2.py", line 15, in <module>
    from p4.tmp import p4config_pb2
ModuleNotFoundError: No module named 'p4.tmp'
../../utils/Makefile:35: recipe for target 'run' failed
make: *** [run] Error 1
```

提示我们没有找到`p4.tmp`模块。

我们使用命令`pip show p4`查看python 的p4模块安装的位置：

![image-20230218194103913](img/image-20230218194103913.png)

该目录中的p4是使用pip安装程序没有使用sudo导致包安在了用户目录下而不是系统目录下，我们应该避免该情况，同时我们查看该p4包发现内容不全：

![image-20230218194320648](img/image-20230218194320648.png)

接着发现python的系统安装目录`dist-packages`

![image-20230218211850358](img/image-20230218211850358.png)

与`site-packages`下都有p4包。

![image-20230218194447442](img/image-20230218194447442.png)

> 查看资料学习`dist-packages`与`site-packages`的区别。
>
> 简单来说
>
> - 如果是系统自带的python，会使用`dist-packages`目录；path: `/usr/local/lib/python3.6/dist-packages/`
>
> - 如果你手动安装python，它会直接使用目录`site-packages`。path ：`/usr/local/lib/python3.6/site-packages/`

终于在`site-packages`找到了我们需要的完整的p4模块了。

接着在终端使用：

``` python
ubt@ubt-vm:/usr/local/lib/python3.6/site-packages$ python
Python 3.6.9 (default, Nov 25 2022, 14:10:45) 
[GCC 8.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> print(sys.path)
['', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/usr/local/lib/python3.6/dist-packages', '/usr/local/lib/python3.6/dist-packages/thrift-0.11.0-py3.6-linux-x86_64.egg', '/usr/local/lib/python3.6/dist-packages/ptf-0.9.3-py3.6.egg', '/usr/local/lib/python3.6/dist-packages/six-1.16.0-py3.6.egg', '/home/ubt/p4-tools/p4-utils', '/usr/local/lib/python3.6/site-packages', '/usr/lib/python3/dist-packages']
```

可以看出`dist-packages`和`site-packages` 都是python系统目录，所以只需将python用户目录下的p4包删掉即可。使用`pip uninstall p4`删除。使用`sudo pip install p4` 安装即可。

还有另一种方法也可以，将完整正确的p4模块放在`/tutorials/utils/`，即 `cp -r /usr/local/lib/python3.6/site-packages/p4/   ~/tutorials/utils/`，让python程序直接在同级目录下引用p4包即可，但此方法拓展性较差，推荐上一种方法。

此时我们继续运行basic例程，发现没有包找不到p4的错了，而报新的错了：

``` bash
ubt@ubt-vm:~/tutorials/exercises/basic$ make
mkdir -p build pcaps logs
p4c-bm2-ss --p4v 16 --p4runtime-files build/basic.p4.p4info.txt -o build/basic.json basic.p4
sudo python3 ../../utils/run_exercise.py -t pod-topo/topology.json -j build/basic.json -b simple_switch_grpc
Traceback (most recent call last):
  File "../../utils/run_exercise.py", line 28, in <module>
    import p4runtime_lib.simple_controller
  File "/home/ubt/tutorials/utils/p4runtime_lib/simple_controller.py", line 24, in <module>
    from . import bmv2, helper
  File "/home/ubt/tutorials/utils/p4runtime_lib/bmv2.py", line 17, in <module>
    from .switch import SwitchConnection
  File "/home/ubt/tutorials/utils/p4runtime_lib/switch.py", line 21, in <module>
    from p4.v1 import p4runtime_pb2, p4runtime_pb2_grpc
  File "/home/ubt/tutorials/utils/p4/v1/p4runtime_pb2.py", line 17, in <module>
    from google.rpc import status_pb2 as google_dot_rpc_dot_status__pb2
  File "/usr/local/lib/python3.6/dist-packages/google/rpc/status_pb2.py", line 39, in <module>
    _STATUS = DESCRIPTOR.message_types_by_name["Status"]
AttributeError: 'NoneType' object has no attribute 'message_types_by_name'
../../utils/Makefile:35: recipe for target 'run' failed
make: *** [run] Error 1
```

在网上搜索该问题发现可能是protobuf版本太高了，查看其版本：

``` bash
ubt@ubt-vm:~/tutorials/exercises/basic$ pip show protobuf
Name: protobuf
Version: 3.18.3
Summary: Protocol Buffers
Home-page: https://developers.google.com/protocol-buffers/
Author: None
Author-email: None
License: 3-Clause BSD License
Location: /usr/local/lib/python3.6/dist-packages
Requires: 
```

查看`~/p4-utils/install-tools/install-p4-dev.sh`发现其中的安装文档发现`PROTOBUF_VER="3.6.1"`

于是卸载当前版本，下载3.6.1版本的。

``` bash
sudo pip uninstall protobuf
sudo pip install protobuf==3.6.1
```

然后运行例程，运行成功了。

此时运行p4-learning中的例程发现这里的例程需要 3.18.3 版本。

![image-20230218213314166](img/image-20230218213314166.png)

这里又报错了，无语。

反复测试发现，p4-learning例程一定需要protobuf3.18.3版本，tutorial例程用这个版本就不行，用protobuf3.6.1版本就可以。只能二选其一，暂时安装3.6.1版本吧。

`sudo pip install protobuf==3.18.3`

`sudo pip install protobuf==3.6.1`

 安装新版本会默认将旧版本删除

## 二、安装torch环境后在有torch环境中使用p4的相关模块

p4的相关模块包括：p4, grpc, protobuf

grpc 安装时模块名叫 grpcio.

由于torch环境中安装的各个模块版本可能都较高，可能需要与系统自带的python环境对比看看哪些包需要改，大概是上面三个。



## P4 术语理解

https://github.com/p4lang/behavioral-model

- **`bmv2`**：**软件交换机**，仅用于科研开发，非生产级。它将JSON文件（用P4编译器编译P4程序得到）作为输入，并对其进行解释，以实现P4程序指定的数据包处理行为。，它旨在用作开发、测试和调试P4数据平面和为其编写的控制平面软件的工具。因此，bmv2在吞吐量和延迟方面的性能明显低于Open vSwitch等生产级软件交换机。

- **`p4c`**  :  包含bmv2后端，是推荐使用的**p4编译器**，因为它同时支持P4_14和P4_16程序。目前，bmv2 p4c后端支持v1model架构，并对PSA架构提供了一些初步支持。为v1model编写的P4_16程序可以使用simple_switch二进制文件执行，而为PSA编写的程序可以使用PSA_switch二进制执行。

## P4代码API

P4程序在bmv2交换机上使用V1Model架构编写，V1Model的架构文件可以在：**`/usr/local/share/p4c/p4include/V1Model.p4`**中找到。该文件描述了架构中p4可编程元件的接口。

https://github.com/p4lang/behavioral-model/blob/main/docs/simple_switch.md

`V1Model.p4` 首先介绍了一些字段的别名，然后简单描述了P4代码中可以使用的一些API，以下做简单介绍(更具体的见源文件)：

### extern

- **`counter(bit<32> size, CounterType type)`** ：计数器，**计数器可以从P4程序更新，但只能从控制平面读取**。如果您需要可以从P4程序读取和写入的内容，请考虑使用寄存器。

    计数器附加在每个表项之后，并在完成一次匹配并执行对应操作后自增1。计数器中定义了7种属性，下图展示了V1.1中计数器的定义方式。

       A counter object is created by calling its constructor.  This     creates an array of counter states, with the number of counter     states specified by the size parameter.  The array indices are      in the range [0, size-1].     You must provide a choice of whether to maintain only a packet    count (CounterType.packets), only a byte count     (CounterType.bytes), or both (CounterType.packets_and_bytes).     Counters can be updated from your P4 program, but can only be   read from the control plane.  If you need something that can be    both read and written from the P4 program, consider using a    register.

    ![img](img/P4-program-fig-9.png)

- **`meter(bit<32> size, MeterType type)`**：计量器对象，例如，如果您的系统中有128个不同的“流”，编号从0到127，并且您希望对这些流中的每一个进行独立计量，您可以通过创建一个大小为128的计量器对象来实现。您必须根据数据包的数量来选择是否进行计量，而不管数据包的大小（MeterType.packets），或者基于分组包含的字节数（MeterType.bytes）。

    计量器的定义与计数器类似，计量器中定义了6种属性，下图展示了V1.1中计数器的定义方式。
    ![img](img/P4-program-fig-10.png)

- **`register<T>`**，寄存器。构造函数：`register(bit<32> size)`，用例：`register<bit<32>>(512) my_reg`，表示一个长度512的寄存器，其中存储的数据类型是`bit<32>`。通过`void read(out T result, in bit<32> index)`函数和`void write(in bit<32> index, in T value)`函数可以对寄存器进行读写。甚至可以给一些读写操作加上`@atomic`原子操作的注释。

    寄存器定义了5种属性，下图展示了V1.1中寄存器的定义方式。
    ![img](img/P4-program-fig-11.png)

- **`random<T>(out T result, in T lo, in T hi)`**，随机数生成器，随机生成一个`lo~hi`之间的数字并赋值给result。

- **`digest<T>(in bit<32> receiver, in T data)`**，向控制平面发送摘要。调用摘要会将包含数据参数中指定值的消息发送到控制平面软件。它类似于将数据包的克隆发送到控制平面软件，但它可以更有效(因为消息通常比数据包小)，而且许多这样的小摘要消息通常被合并到一个更大的“batch”中，控制平面软件可以一次处理所有这些消息。在消息中发送到控制平面的字段值是它们在摘要调用发生时的值，即使这些字段值被稍后的入口控制代码更改。仅在`ingress control`中支持调用摘要。一旦调用了它，就无法撤消其效果。（第一个参数永远填 1 ）

- **`mark_to_drop(inout standard_metadata_t standard_metadata)`**：是将`standard_metadata.egress_spec`修改为特定于实现的特殊值的原始动作，在某些情况下。它还将0指定给`standard_metadata.mcast_grp`。在调用`mark_to_drop()`之后，可以通过执行稍后的P4代码来更改这些元数据字段中的任何一个，这可以将数据包的结果行为更改为执行drop以外的操作。

- **`hash<O, T, D, M>(out O result, in HashAlgorithm algo, in T base, in D data, in M max)`**：根据参数`data`计算哈希值，将结果写入`result`中，其范围是`[base, base+max-1]`（max>=1时），如果max=0，result就只是base了。其中泛型都是`bit<w>`，（当然w可以不一样），`data`可以时元组。

- **`verify_checksum<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo)`**：验证data 的检验和，只能在`VerifyChecksum  control`中使用。如果此方法检测到数据的校验和不正确，则当数据包开始进入处理时，`standard_metadata.checksum_error`字段的值将等于1。

- **`update_checksum<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo)`**：计算检验和，只能在`ComputeChecksumcontrol`中使用。

- **`verify_checksum_with_payload<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo)`**：带负载的检验和，基本同上，只是计算时包括负载。（负载可以理解为没有被parser解析的所有比特）。

- **`update_checksum_with_payload<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo)`**：带负载的计算检验和。

- **`resubmit<T>(in T data)`**：重新提交数据包。仅在**`ingress processing`**中支持调用重新提交。即它将再次开始使用解析器进行处理，数据包的**内容**与上次解析完全**相同**，**唯一的区别**在于`standard_metadata instance_type`字段的值，以及重新提交操作导致保留的任何用户定义的元数据字段。保留在重新提交的数据包中的**用户定义元数据字段**的值是它们在**`ingress processing`**结束时的值，而不是它们在进行重新提交调用时的值。如果在一次执行入口控制期间多次调用resubmit，则只会重新提交一个数据包，并且只保留上次调用的数据。

- **`recirculate<T>(in T data)`**：数据包再循环。仅在**`egress processing`**中支持调用。简单理解就是将数据包通过`deparser`处理后，将数据包再次进入`parser`进行处理。保留在再循环数据包中的用户定义元数据字段的值是它们在**`egress processing`**结束时的值，而不是它们在进行再循环调用时的值。

- **`clone3<T>(in CloneType type, in bit<32> session, in T data)`**：数据包克隆或镜像，在`ingress or egress control`中调用。克隆包与原始包相互独立，该进行什么操作就进行什么操作。

- **`clone(in CloneType type, in bit<32> session)`**，相当于`clone3()`的简化版，不会保留任何用户定义**元数据字段**，所以如果需要clone时保留一些元数据信息就要自定义一些。

- **`assert(in bool check)`**：断言，例如，在simple_switch目标上，执行带有false参数的assert语句会导致打印带有assert语句的文件名和行号的日志消息，然后simple_switch进程退出。

- **`assume(in bool check)`**您可以向P4程序添加额外的条件，以便在断言不失败的情况下，清晰地处理此类数据包的处理

- **`log_msg(string msg)`与`log_msg<T>(string msg, in T data)`**：记录日志，例：`log_msg("User defined message");` ,   `log_msg("Value1 = {}, Value2 = {}",{value1, value2});`.

- **`extern void truncate(in bit<32> length)`**  对当前数据包进行截断，直接使用，例：truncate((bit<32>)22);    表示截断到剩22个字节

  ​    

注：包头和元数据实例中的数据只能存在对某个数据包解析的过程中，解析下一个数据包时，这些实例会重新初始化。而**计数器、计量器和寄存器**中的数据在整个流水线中长期存在，所以称之为状态存储。

接下来就是P4文件的基本结构：

``` c++
/*
 * Architecture.
 *
 * M must be a struct.
 *
 * H must be a struct where every one if its members is of type
 * header, header stack, or header_union.
 */

parser Parser<H, M>(packet_in b,
                    out H parsedHdr,
                    inout M meta,
                    inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the VerifyChecksum control
 * are: block statements, calls to the verify_checksum and
 * verify_checksum_with_payload methods, and return statements.
 */
control VerifyChecksum<H, M>(inout H hdr,
                             inout M meta);
@pipeline
control Ingress<H, M>(inout H hdr,
                      inout M meta,
                      inout standard_metadata_t standard_metadata);
@pipeline
control Egress<H, M>(inout H hdr,
                     inout M meta,
                     inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the ComputeChecksum
 * control are: block statements, calls to the update_checksum and
 * update_checksum_with_payload methods, and return statements.
 */
control ComputeChecksum<H, M>(inout H hdr,
                              inout M meta);

/*
 * The only legal statements in the body of the Deparser control are:
 * calls to the packet_out.emit() method.
 */
@deparser
control Deparser<H>(packet_out b, in H hdr);

package V1Switch<H, M>(Parser<H, M> p,
                       VerifyChecksum<H, M> vr,
                       Ingress<H, M> ig,
                       Egress<H, M> eg,
                       ComputeChecksum<H, M> ck,
                       Deparser<H> dep
                       );

```

### **元数据-metadata**

https://www.cnblogs.com/mike1024/p/14847129.html

V1Model的架构文件可以在：**`/usr/local/share/p4c/p4include/V1Model.p4`**中

元数据是（数据包 -- 交换机）关联的，不会在网络中传递。

元数据是用来携带数据和配置性的东西，元数据的申明与包头类似，但在实例化的时候有所不同，而且包头和元数据在字段值的约束上存在一定的差别。

元数据分为两种，一种是用来携带P4程序运行过程中产生的数据的用户自定义元数据（User-Defined Metadata），如首部字段的运算结果等。另一种是固有元数据（Intrinsic Metadata），用于携带交换机自身的配置信息，如数据包进入交换机时的端口号等。

- 自定义元数据：开发者自定义metadata，定义方式和header一样。然后可以直接应用在Action和Control里。

- 固有元数据**`standard_metadata.some_field`**：可以直接使用。

有**8种标准固有元数据**，这些元数据携带了数据包相关的状态信息。

- **`ingress_port` ：**数据包的入端口，解析之前设置，**只读**。
- **`egress_spec `：**（根据P4_14 v1.0.4规范中的表3，必须在入口管道中为egress_spec分配一个值，）在入端口流水线的匹配-动作过程之后设置，**指定数据包出端口**，可以是物理端口、逻辑端口或者多播组。它一般在ingress由P4代码指定数据包离开当前交换机的出端口。
- **`egress_port` ：**数据包的出端口（**只读**），其中的值其实就是ingress中使用 egress_spec写的值 。一般在egress里面读取以进行不同的操作。
- **`packet_length`：**数据包的字节数，当交换机在快速转发模式下，该元数据不能在动作（action）中匹配或引用。只读。
- **`egress_instance `：**用于区分复制后数据包实例的标识符。只读。
- **`instance_type`：**数据包实例类型：正常（Normal）、入端口复制（ingress clone）、出端口复制（egress clone）、再循环（recirculated）。
- **`parser_status `**: 解析器解析结果，0表示无错误，其实数字代表了对应的错误类型。
- **`parser_error_location` ：**指向P4程序错误发生处。

还有更多额外内部元数据以实现更多功能（v1model体系结构下）：

[看看有趣的P4 BMv2 Ⅰ：simple_switch.md - 简书 (jianshu.com)](https://www.jianshu.com/p/044761dc2ea9)

- **`ingress_global_timestamp`**：时间戳（以微秒为单位），当数据包在入口出现时设置。每次交换机启动时，时钟都设置为0。可以直接从任一管道（入口和出口）读取此字段，但不应将其写入。++++
- **`egress_global_timestamp`**：时间戳（以微秒为单位），当数据包开始进行出口处理时设置。时钟与相同**`ingress_global_timestamp`**。该字段只能从出口管道中读取，而不能写入。++++
- **`mcast_grp`**：多播功能所需。当您希望对数据包进行多播时，需要在入口管道中写入此字段。值为0表示无组播。该值必须是通过bmv2运行时接口配置的有效多播组之一。请参阅“入口后伪代码”，以了解入口结束时此相对于其他可能的数据包操作的相对优先级。
- **`egress_rid`**：多播功能所需。该字段仅在出口管道中有效，并且只能从中读取。它用于唯一标识同一入口数据包的多播副本。

**以下字段只在 出口管道 可以访问**：

- **`enq_timestamp`**：时间戳，以毫秒为单位，设置首次将数据包加入队列的时间。+++
- **`enq_qdepth`**：首次将数据包**排入队列**时的队列深度，以数据包数（而不是数据包的总大小）为单位。要在egress里面用++++
- **`deq_timedelta`**：数据包在队列中花费的时间（以微秒为单位）。32bit
- **`deq_qdepth`**：数据包**出队**时的队列深度，以数据包数量（而不是数据包的总大小）为单位。+++
- **`qid`**：：当有多个队列服务每个出口端口时（例如，启用优先级队列时），每个队列都分配有固定的唯一ID，并将其写入此字段。否则，此字段设置为0。TBD：`qid`当前不是`standard_metadata_t`v1model中类型的一部分。也许应该添加？

根据自动上游节点的反馈控制输入的流量，

在 *mininet* 中`xterm s1`可进入交换机s1中，在新的prompt中输入`simple_switch_CLI --thrift-port 9090` (s1是9090，s2是9091，以此类推)，进入交换机内部，之后输入`help`可以查看有哪些命令。

例如：`register_read <寄存器名>`：查看寄存器内容

1. 屏蔽原有拥塞控制算法
2. 例，10M带宽链路我们打80M流量，我们的算法可以1，2秒内让速率收敛，比其他的快。

### varbit（变长位串）

[P4~16~ Language Specification](https://p4.org/p4-spec/docs/P4-16-v1.1.0-spec.html)

该数据类型，不支持算术、比较和位运算，也不支持类型转换，该数据类型在定义时会指定一个**静态的最大宽度值**，解析器会提取变长位串数据并设置一个值作为长度。在初始化之前，可变大小的位串具有未知的动态宽度。

***可变长度位串支持有限的一组操作：***

- **使用`packet_in`外部对象的双参数`extract`方法将解析器提取为可变大小的位字符串**（参见第12.8.3节）。此操作设置字段的动态宽度。

- **分配给另一个可变大小的位字符串**。赋值的目标必须与源具有相同的静态宽度。执行时，赋值将目标的动态宽度设置为源的动态宽度。

- **`packet_out`外部对象的`emit`方法**，它将具有已知动态宽度的可变大小的位串插入到正在构建的数据包中（参见第15节）。

- **与另一个`varbit`字段进行相等或不相等的比较**。只有当两个varbit字段具有相同的类型时，才能对它们进行比较。如果两个变量位具有相同的动态宽度，并且直到动态宽度的所有位都相同，则两个变量是相等的。

**`varbit`的提取 :**

```  c
void extract<T>(out T headerLvalue, in bit<32> variableFieldSize);
```

表达式`headerLvalue`必须是一个左值，表示仅包含**一个`varbit`字段**的头部。表达式`variableFieldSize`的值必须为`bit＜32＞`，该值指示要提取到标头的**唯一varbit字段中的位数**（即，该大小不是完整标头的大小，只是varbit字段）。

### p4中得到随机数

``` c
extern void random<T>(out T result, in T lo, in T hi);
```

输入范围为 `[lo, hi]`，输出结果保存在`result`中。

## iperf 工具

iperf命令是基于命令行模式的网络性能测试工具，可以**测试TCP和UDP带宽质量**。同时也可以通过UDP测试报告网络**丢包率**或者**发包性能**，是一个非常实用的工具。

iperf 提供横跨Windows、Linux、Mac的全平台支持。iperf 全程使用内存作为发送/接收缓冲区，不受磁盘性能的影响，对于机器配置要求很低。不过由于是命令行工具， iperf 不支持输出测试图形。

目前最新版是iperf3，与iperf 相差不大。iperf 默认只监听TCP，iperf3 默认监听TCP 和 UDP。

### 安装

ubuntu下：`sudo apt install iperf` 

### 使用

Iperf可以运行在任何IP网络上，包括本地以太网、接入因特网、Wi-Fi网络等。

在iperf中，默认情况下，数据流是从客户端 (c) 到服务器端 (s) 发送的。

在工作模式上，iperf运行于C/S 客户端/服务器模式下，其**服务器端主要用于监听到达的测试请求**，而**客户端主要用于发起测试连接会话**，因此要使用iperf至少需要两台机器，一台运行在服务器模式下，另一台运行在客户端模式下。

查看帮助： `iperf --help`或`iperf -h` 

查看当前版本： `iperf --version`或`iperf -v` 

基本用法：`iperf [-s|-c] [options]`

通过查看帮助知道，iperf的命令行选项共分为三类，分别是**客户端与服务器端公用选项**、**服务器端专用选项**和**客户端专用选项**。

#### iperf基本参数

[Iperf3网络性能测试工具详解教程 - pycod - 博客园 (cnblogs.com)](https://www.cnblogs.com/xuanbjut/p/14144255.html)

- :ocean:**`-s, –server`**：iperf服务器模式，默认启动的监听端口为5201，eg：`iperf -s`
- :car: **`-c, –client`** ：iperf客户端模式，host是server端地址，eg：`iperf -c 222.35.11.23`
- :ocean: :car: **`-B`** ：后跟ip地址。在服务端，设置数据从哪个网卡接收；在客户端，设置数据从哪个网卡发送。
- :ocean:**`-D`**：Unix平台下将Iperf作为后台守护进程运行。在Win32平台下，Iperf将作为服务运行。
- :ocean::car: **`-i，–interval`**：指定每次报告之间的时间间隔，单位为秒，eg：`iperf3 -c 192.168.12.168 -i 2`
- :ocean::car: **`-f，–format [k|m|g|K|M|G]`**：指定带宽输出单位，“[k|m|g|K|M|G]”分别表示以Kbits, Mbits, Gbits, KBytes, MBytes,GBytes显示输出结果，默认Mbits，eg：`iperf3 -c 192.168.12.168 -f M`
- :ocean::car: **`-p，–port`**：指定服务器端监听的端口或客户端所连接的端口，默认是5001端口。
- :ocean::car:**`-P,–parallel`**：server中：服务器关闭之前保持的连接数。默认是0，这意味着永远接受连接。client中：指定客户端与服务端之间使用的线程数。默认是1个线程。需要客户端与服务器端同时使用此参数。 
- :ocean::car: **`-u，–udp`**：表示采用UDP协议发送报文，不带该参数表示采用TCP协议，iperf3 直接监听tcp和udp了，所以iperf3的服务端不能用这 个命令。
- :car: **`-l，–len`**：设置读写缓冲区的长度，单位为 Byte。**TCP方式默认为8KB**，**UDP方式默认为1470字节**。通常测试 PPS 的时候该值为16，测试BPS时该值为1400。
- :car: **`-n，–num [K|M|G]`**：指定传输数据包的字节数，例如：`iperf3 -c 192.168.12.168 –n 100M`
- :car: **`-b，–bandwidth [K|M|G]`**：指定使用的带宽，**单位bits/sec**，**默认值是1 Mbit/sec**。
- :car:  **`-w，–window`**：指定套接字缓冲区大小，在TCP方式下，此设置为**TCP窗口的大小**。在UDP方式下，此设置为接受**UDP数据包的缓冲区大小**，用来限制可以接收数据包的最大值
- :car: **`-t，–time`**：指定数据传输的总时间，即在指定的时间内，重复发送指定长度的数据包。默认10秒。
- :car:**`-A`**：CPU亲和性，可以将具体的iperf3进程绑定对应编号的逻辑CPU，避免iperf进程在不同的CPU间调度。

:car: ：表示该选项用于 Client

:ocean: ：表示该选项用于 Server

**使用示例：**

在自己的服务器运行：`iperf -s -i 1 -p 8100`：以服务器方式打开，每 1 秒打印一次报告，监听端口8100（默认端口没开）。

在客户机：`iperf -c 49.232.21.36 -i 1 -p 8100`：以客户端方式打开，连接IP地址49.232.21.36，每 1 秒打印一次报告，连接端口8100。

## simple_switch_CLI

对mininet交换机内部数据进行读取和设置。

再命令行输入 **`simple_switch_CLI --thrift-port 9090`** 进入交换机内部，其中9090是s1交换机，9091是s2，以此类推。

输入**`help`**查看有哪些命令，read相关的命令直接查看相应参数，set相关的需要带参数进行设置，

例如：**`set_queue_rate 7600`** 设置交换机**所有端口**的处理速率为每秒7600个包。

register_read pkt_counter

register_read threshold

table_dump ipv4_lpm

## 影响P4性能的因素

- 程序越简单（即 parsed / deparsed 的头的数量越少，match-action tables的数量越小，等等），吞吐量越高，时延越低。

https://github.com/p4lang/behavioral-model/blob/main/docs/performance.md



| 设置的发包比例 | 是否发ECN | 设置的bw   | set_queue_rate   | 最后收敛的带宽 |
| -------------- | --------- | ---------- | ---------------- | -------------- |
| 6：3：1        | 0         | 20：40：60 | 3000：5000：7000 | 15 ~ 17        |
| 6：3：1        | 1         | 20：40：60 | 3000：5000：7000 | 35 ~ 37        |
| 1：1：1        | 0         | 20：40：60 | 3000：5000：7000 | 32 ~ 41        |
| 1：1：1        | 0         | 0          | 3000：5000：7000 | 49.1           |
| 1：1：1        | 0         | 20：40：60 | 0                | 45.3           |
| 1：3：6        | 0         | 20：40：60 | 3000：5000：7000 | 38 ~ 42        |
| 1：3：6        | 0         | 20：40：60 | 0                | 44.6           |
| 1：3：6        | 0         | 0          | 3000：5000：7000 | 48.6           |
| 1：3：6        | 0         | 10：30：60 | 0                | 46.9           |
| 50:33:17       | 1         | 20：40：60 | 0                | 41.5           |

iperf -s -i 1

iperf  -i 1 -t 100 -c 10.0.



## bfrt

 在barefoot实体P4交换机中，有一个python程序一直管理着P4功能。

在开启端口后使用 `bfrt_python` 进入此python程序的命令行控制台中。此python程序以**树**的形式保存着此P4程序相关的数据结构。

``` txt
bfrt
  - mirror
  - port
  - pre
  - [此P4文件]
    - pipe
      - Ingress
        - 所有的table
        - 所有的寄存器
      - IngressParser
      - ...
```

simple_switch_CLI --thrift-port 9090

## meter外部函数学习
在 P4 语言和 BMv2 环境中，计量器（meter）是用来执行流量监控与排队策略的组件，可以用于多种目的，比如速率限制或者流量分级。
***计量器的配置***
包含两个核心参数：速率（rate）和突发值（burst）。
- 速率（rate）：这是一个流可以发送数据的平均速率的阈值。速率的单位通常是单位时间（如秒或者微秒）内的字节数或者包数。在 BMv2 的默认配置中，速率通常以每微秒（units/microsecond）的单位来表示。配置meter的速率时，通常是以bits per second (bps) 或者 packets per second (pps)来进行配置的。bits per second 字面上是以“比特每秒”计，而 packets per second 是以“包每秒”计。所以，无论是以bps还是pps配置rate，它们都与时间单位微秒（microsecond）有关，但是在配置时通常使用的时间单位是秒（second）。

- 突发值（burst）：这是一个大小阈值，它表示在短时间burst内流所发送的最大连续字节数或者包数，而不会被视为超出设定的速率。突发值有时可以允许流短暂地以比配置的速率更高的速度传输数据，但不会触发任何排队或者丢包。它的单位和速率的单位是一起考虑的，通常也是字节或者包。突发大小通常用bytes或packets来配置。

***计量器作用：***
- 绿色（Green）：如果流量的速率没有超过配置的速率阈值，即流量的行为是符合预先定义的策略的，计量器将该流量标记为绿色。
- 黄色（Yellow）：如果流量超过了平均速率但没有超过突发值允许的范围，流量可能会被标记为黄色。这意味着流量短暂地超出了正常发送速率，但仍在接受的范围内。
- 红色（Red）：如果流量既超过了平均速率又超过了突发值，流量会被标记为红色。这通常表示流量显著超出了所配置的速率和突发阈值，并可能遭到丢包或其他排队策略的处理。
返回红色的情况通常发生在流量持续以超过突发值的速率流入系统时。这种监控可以帮助网络系统识别和控制可能会对网络性能产生负面影响的流量，如洪水攻击或非预期的流量激增。

总之，计量器通过不同的颜色标志来表示流量是否符合定义的速率和突发阈值。管理员可以定义网络应如何处理每种颜色的流量，例如将红色流量丢弃或重新标记。

***相关实验***
在github P4-learning 文件夹里有meter相关介绍实验，主要有两个：
- **`exercises/04-RSVP/thrift`** https://github.com/nsg-ethz/p4-learning/tree/0ddba187f207e24a8a614f5d1abf8bc11998c9d3/exercises/04-RSVP/thrift/solution
主要应用meter做服务资源预留和区分服务
- **`examples/meter`** https://github.com/nsg-ethz/p4-learning/tree/master/examples/meter
是meter的应用

**`meter`** 有两种，一种是 **`indirect_meter`**，另一种是  **`direct_meter`** 。有两种类型`MeterType.packets` 、`MeterType.bytes`按数据包统计或按字节统计，

`P4-learning/examples/meter`中对于每个传入数据包，应用`m_read`表，基于数据包的源 MAC 地址进行测量。基于观察到此发送方的流量速率和`meter`的配置，产生 3 个值之一：`0`GREEN、`1`YELLOW 或 `2`RED 放到`meta.meter_tag`。后续应用表`m_filter`对不同`meta.meter_tag`执行操作（观察流表得到是为`0`则无操作，其他的直接默认`drop`。
**`direct_meter`** 是与表条目关联，而 **`indirect_meter`** 可以是按索引寻址。

### **`indirect_meter`** 用法
```C
//定义indirect_meter
meter(32w16384, MeterType.packets) my_meter;
//匹配的table
table m_read {
        key = {
            hdr.ethernet.srcAddr: exact;
        }
        actions = {
            m_action;
            NoAction;
        }
        default_action = NoAction;
        size = 16384;
    }
//执行的action，table会返回meter_index，颜色值返回原数据meta.meter_tag
action m_action(bit<32> meter_index) {
        my_meter.execute_meter<bit<32>>(meter_index, meta.meter_tag);
    }

```
### **`direct_meter`** 用法
```C
//定义一个direct_meter
 direct_meter<bit<32>>(MeterType.packets) my_meter;
//匹配的table，应用direct必须在table中添加meters = 你的meter的名字;
 table m_read {
        key = {
            hdr.ethernet.srcAddr: exact;
        }
        actions = {
            m_action;
            NoAction;
        }
        default_action = NoAction;
        meters = my_meter;
        size = 16384;
    }
//read操作只能在匹配的表项的结果中调用
//执行的action，table会返回meter_index，颜色值返回原数据meta.meter_tag
action m_action() {
        my_meter.read(meta.meter_tag);
    }
```
### **`meter`** 的流表下发

#### ONOS控制器配置meter(Chat-GPT写的，不保真)
ONOS 的 Northbound (北向) API 提供了 REST API 接口，使得可以通过 HTTP 请求来管理网络中的 Meter。这包括添加、删除、查询和修改 Meter 设置。
以下是一些使用 ONOS API 来操作 Meter 的例子：
添加 Meter:
```bash
curl -X POST -u onos:rocks -H "Content-Type: application/json" "http://<onos-ip>:8181/onos/v1/meters/<deviceId>" -d '
{
    "unit": "KB_PER_SEC",
    "bands": [
        {
            "type": "DROP",
            "rate": 1000,
            "burstSize": 100
        }
    ]
}'
```
这里 <onos-ip> 是你的 ONOS 控制器的 IP 地址，而 <deviceId> 是你想配置 Meter 的网络设备的 ID。
查询 Meter:
```bash
curl -X GET -u onos:rocks "http://<onos-ip>:8181/onos/v1/meters/<deviceId>"
```
删除 Meter:
```bash
curl -X DELETE -u onos:rocks "http://<onos-ip>:8181/onos/v1/meters/<deviceId>/<meterId>"
```
在这个例子中，<meterId> 是要删除的 Meter 的 ID。
使用 ONOS API 时，请确保：
ONOS 控制器运行并可访问。
ONOS 控制器的 REST API 已启用。
你有用于验证的有效 ONOS 用户凭据，不同安装的默认凭据可能有所不同。
已经对网络设备进行初始化和配置，使其可以接受来自 ONOS 的指令。
你指定的 <deviceId> 和 <meterId> 与你的网络设备配置相对应。
这些 API 调用示例可能需要根据你的 ONOS 控制器版本以及你的具体需求进行调整。建议参照 ONOS 的官方文档来获取当前版本最准确的 API 信息和详细指南。

#### BMv2配置meter
如果使用`P4/tutorials`做实验，可以将`topology.json`里的`switches`使用`cli_input`，在调用`run_exercise.py`的时候可以使用`subprocess`应用`simple_switch_CLI`配置。
最终应用的是`/home/sinet/P4/behavioral-model/targets/simple_switch/runtime_CLI`
***
- **`do_meter_array_set_rates(self, line)`**:此函数用于为整个计量器数组配置速率。它接受一个字符串参数，包括计量器数组的名称以及以冒号分隔的速率和突发值对。它解析这些值，验证提供的速率数量是否与预期的速率数量相匹配，构造新的速率配置，并使用`client.bm_meter_array_set_rates` `RPC`调用应用它们。

- 这段代码定义了一个名为do_meter_array_set_rates的函数，它接受一个参数line作为输入。函数的主要功能是配置一个完整的计量器数组（meter array）的速率。函数的使用方式是通过命令行输入一系列速率值，并将其应用于指定的计量器数组。下面是对函数的逐行解释：
```
args = line.split(): 将输入的line按空格分割成一个参数列表，并将其赋给args变量。
self.at_least_n_args(args, 1): 检查参数列表，确保至少有一个参数。at_least_n_args是函数中的一个辅助方法，用于验证参数数量。
meter_name = args[0]: 将参数列表中的第一个参数作为计量器数组的名称，将其赋给meter_name变量。
meter = self.get_res("meter", meter_name, ResType.meter_array): 使用get_res方法获取指定名称的计量器数组对象，并将其赋给meter变量。该方法是类中的一个辅助方法。
rates = args[1:]: 将参数列表中除了第一个参数外的所有参数作为速率列表，将其赋给rates变量。
if len(rates) != meter.rate_count: ...: 检查速率列表的长度是否与计量器数组的速率数目相匹配，如果不匹配，则抛出一个异常。该异常表示速率数量错误。
new_rates = []: 创建一个空列表new_rates，用于存储解析后的速率配置。
for rate in rates: ...: 对速率列表进行循环迭代。
r, b = rate.split(':'): 将每个速率项按冒号分割成两部分，分别赋给r和b变量。其中r表示速率值，b表示突发值。
r = float(r): 将速率值转换为浮点数类型。
b = int(b): 将突发值转换为整数类型。
new_rates.append(BmMeterRateConfig(r, b)): 根据解析后的速率值和突发值创建一个BmMeterRateConfig对象，并将其添加到new_rates列表中。
self.client.bm_meter_array_set_rates(0, meter.name, new_rates): 调用client对象的bm_meter_array_set_rates方法，将计量器数组的索引、名称和新的速率配置作为参数，以配置计量器数组的速率。
该函数的作用是根据命令行输入的速率配置，将新的速率应用于指定的计量器数组，并通过调用bm_meter_array_set_rates方法实现配置的下发。
```
***
- **`complete_meter_array_set_rates(self, text, line, start_index, end_index)`**：关于`meter_array_set_rates`命令的命令行自动补全的辅助函数。
***
- **`do_meter_set_rates(self, line)`**：此函数按索引为计量器数组中的单个计量器配置速率。类似于第一个函数，它处理一行参数，第一个参数是计量器的名称，第二个是计量器数组中的索引，其余的是速率:突发值对。它还验证输入并使用`client.bm_mt_set_meter_rates`（如果计量器直接与一个表关联）或`client.bm_meter_set_rates`（否则）设置计量器速率。
***
- **`complete_meter_set_rates(self, text, line, start_index, end_index)`**：此函数为`meter_set_rates`命令提供自动补全。
***
- **`do_meter_get_rates(self, line)`**：检索指定计量器在给定索引处的当前配置速率。它处理参数（期望有两个：计量器名称和它的索引），执行适当的客户端API调用，这取决于计量器是直接还是间接的，并打印计量器速率配置。
***
- **`complete_meter_get_rates(self, text, line, start_index, end_index)`**：此函数可能为meter_get_rates命令提供自动补全。
***
- **`_complete_meters(self, text)`**：此函数可能支持与计量器相关的命令的自动补全，也许通过基于用户输入的部分文本提供计量器名称或索引列表。
***
***代码源码***

```python
def do_meter_array_set_rates(self, line):
        "Configure rates for an entire meter array: meter_array_set_rates <name> <rate_1>:<burst_1> <rate_2>:<burst_2> ..."
        args = line.split()
        self.at_least_n_args(args, 1)
        meter_name = args[0]
        meter = self.get_res("meter", meter_name, ResType.meter_array)
        rates = args[1:]
        if len(rates) != meter.rate_count:
            raise UIn_Error(
                "Invalid number of rates, expected %d but got %d"
                % (meter.rate_count, len(rates))
            )
        new_rates = []
        for rate in rates:
            try:
                r, b = rate.split(':')
                r = float(r)
                b = int(b)
                new_rates.append(BmMeterRateConfig(r, b))
            except:
                raise UIn_Error("Error while parsing rates")
        self.client.bm_meter_array_set_rates(0, meter.name, new_rates)

    def complete_meter_array_set_rates(self, text, line, start_index, end_index):
        return self._complete_meters(text)

    @handle_bad_input
    def do_meter_set_rates(self, line):
        "Configure rates for a meter: meter_set_rates <name> <index> <rate_1>:<burst_1> <rate_2>:<burst_2> ...\nRate uses units/microsecond and burst uses units where units is bytes or packets"
        args = line.split()
        self.at_least_n_args(args, 2)
        meter_name = args[0]
        meter = self.get_res("meter", meter_name, ResType.meter_array)
        try:
            index = int(args[1])
        except:
            raise UIn_Error("Bad format for index")
        rates = args[2:]
        if len(rates) != meter.rate_count:
            raise UIn_Error(
                "Invalid number of rates, expected %d but got %d"
                % (meter.rate_count, len(rates))
            )
        new_rates = []
        for rate in rates:
            try:
                r, b = rate.split(':')
                r = float(r)
                b = int(b)
                new_rates.append(BmMeterRateConfig(r, b))
            except:
                raise UIn_Error("Error while parsing rates")
        if meter.is_direct:
            table_name = meter.binding
            self.client.bm_mt_set_meter_rates(0, table_name, index, new_rates)
        else:
            self.client.bm_meter_set_rates(0, meter.name, index, new_rates)

    def complete_meter_set_rates(self, text, line, start_index, end_index):
        return self._complete_meters(text)

    @handle_bad_input
    def do_meter_get_rates(self, line):
        "Retrieve rates for a meter: meter_get_rates <name> <index>"
        args = line.split()
        self.exactly_n_args(args, 2)
        meter_name = args[0]
        meter = self.get_res("meter", meter_name, ResType.meter_array)
        try:
            index = int(args[1])
        except:
            raise UIn_Error("Bad format for index")
        # meter.rate_count
        if meter.is_direct:
            table_name = meter.binding
            rates = self.client.bm_mt_get_meter_rates(0, table_name, index)
        else:
            rates = self.client.bm_meter_get_rates(0, meter.name, index)
        if len(rates) != meter.rate_count:
            print("WARNING: expected", meter.rate_count, "rates", end=' ')
            print("but only received", len(rates))
        for idx, rate in enumerate(rates):
            print("{}: info rate = {}, burst size = {}".format(
                idx, rate.units_per_micros, rate.burst_size))
```
**以下内容是Chat-GPT 4的回答，他是一个大傻逼，因为他的回答是错误的**
BMv2 本体并没有直接的 API 来配置 Meter。但是，当你使用诸如 ONOS、P4Runtime等控制平面与 BMv2 交互时，这些控制平面接口提供了通过控制器来配置 BMv2 交换机上的 Meter 的能力。

举个例子，如果你通过 P4Runtime API 与 BMv2 交云机交互，你可以编写 P4Runtime 的客户端代码来实现 Meter 的配置。这通常涉及到发送 MeterEntry 更新消息到 BMv2 模拟交换机。

以下是使用 P4Runtime API 配置 BMv2 交换机上的 Meter 的一个基础的概念：
- 连接: 与 BMv2 交互前，需要建立一个到 BMv2 的 gRPC 连接。
- Meter 配置: 创建一个 MeterEntry 消息来配置特定的 Meter。
- 写入: 通过 P4Runtime API 的 Write RPC 调用将 Meter 配置写入 BMv2。

在 P4Runtime，Meter 的配置与 BMv2 的 SimpleSwitchGrpc 目标一同使用。这需要 P4 程序被编译来支持此目标，并且 BMv2 运行时需要有相应的 P4Runtime 服务接口。

另外，Simple_switch_CLI 是 BMv2 的一个组件，它提供了一组 CLI 命令用于交互式地配置和监控 BMv2 交换机。虽然 Simple_switch_CLI 没有提供专门的 Meter 配置命令，但它允许操作交换机中的许多其他功能（如表格和寄存器）。

通常情况下，Meter 的配置和管理由控制器（如 ONOS, P4Runtime API 等）通过适合的南向接口向 BMv2 发送指令来完成。要配置 BMv2 交换机上的 Meter，你可以通过 P4Runtime API 或者其他南向接口来实现规则的添加、删除和修改。这通常涉及到控制器中的网络应用编写相关的网络控制逻辑和消息序列化与反序列化。

#### P4Runtime配置meter(Chat-GPT写的，不保真)
在P4Runtime API中，配置Meter的操作是通过MeterEntry消息在WriteRequest中进行的。MeterEntry被用来表示控制器对于交换机中的一个Meter对象的配置。P4Runtime API是一个protobuf和gRPC基于的API，用于控制支持P4Runtime的交换机（包括BMv2交换机）。

以下是利用P4Runtime API配置Meter的基本步骤：

- 构建MeterEntry消息：这个消息需要包括识别Meter的信息（例如Meter ID或名称）以及Meter的配置参数，比如速率（rate）和突发大小（burst_size）。
- 创建WriteRequest消息：将MeterEntry加入到一个WriteRequest消息中。这个请求可以包括一个或多个更新操作，每一个都有其自己的EntityType和Entity。
- 发送gRPC请求：通过gRPC将WriteRequest发送给交换机。这通常需要与交换机的P4Runtime服务建立一个gRPC通道，并由控制器发送请求。

这里有一个简化的Meter配置的例子，使用了P4Runtime的protobuf定义：
```protobuf
message MeterEntry {
    uint32 meter_id = 1; // Meter的ID，来自于P4程序的定义
    // 重复字段，支持对全部Meter条目或单个Meter条目的配置
    repeated int64 index = 2; // Meter条目的索引
    enum Config {
        UNKNOWN = 0;
        COLOR_AWARE = 1;
        COLOR_UNAWARE = 2;
    }
    // Meter的类型，基于颜色的感知或不感知
    Config config = 3;
    // Meter配置的细节，如速率和突发大小
    message MeterBand {
        uint64 rate = 1; // 速率
        uint64 burst_size = 2; // 突发大小
    }
    repeated MeterBand meter_band = 4; // Meter的带宽配置
}

message WriteRequest {
    uint64 device_id = 1; // 设备ID
    // 其他相关信息 ...

    // 实体更新列表
    repeated Update updates = 10;
    message Update {
        enum Type {
            UNSPECIFIED = 0;
            INSERT = 1;
            MODIFY = 2;
            DELETE = 3;
        }
        Type type = 1;
        Entity entity = 2;
    }
    message Entity {
        // 选择其中一项用于更新
        oneof entity {
            // 其他entity类型...
            MeterEntry meter_entry = 7; // MeterEntry
        }
    }
}
```
控制器则需要将这个MeterEntry包装进WriteRequest并通过P4Runtime gRPC接口发送给交换机。Meter更新可以是插入（INSERT），修改（MODIFY），或删除（DELETE）。

这个流程需要正确的protobuf和gRPC接口设置，以及与P4Runtime服务的通信配置。这些操作通常由网络控制器软件来管理，如在ONOS或OpenDaylight这样的SDN控制器中。

请注意，要实现具体的Meter配置，你需要具体的P4Runtime库以及相关软件来和交换机通信。Meter的确切配置细节将依赖于你的P4程序和交换机的能力。

上述内容提供概念性的解释，实际的实现涉及复杂的网络编程，并在实际部署中需要适当的安全措施（如对gRPC通信的认证和加密）。



### **`v1model.p4`** 中关于`meter`的阐述
```C
extern meter
#if V1MODEL_VERSION >= 20200408
<I>
#endif
{
    /***
     * A meter object is created by calling its constructor.  This
     * creates an array of meter states, with the number of meter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].  For example, if in your system you
     * have 128 different "flows" numbered from 0 up to 127, and you
     * want to meter each of those flows independently of each other,
     * you could do so by creating a meter object with size=128.
     *
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).
     */
    meter(bit<32> size, MeterType type);
    // FIXME -- size arg should be `int` but that breaks typechecking

    /***
     * execute_meter() causes the meter state with the specified index
     * to be read, modified, and written back, atomically relative to
     * the processing of other packets, and an integer encoding of one
     * of the colors green, yellow, or red to be written to the result
     * out parameter.
     *
     * @param index The index of the meter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no meter state will be
     *              updated.
     * @param result Type T must be bit<W> with W >= 2.  When index is
     *              in range, the value of result will be assigned 0
     *              for color GREEN, 1 for color YELLOW, and 2 for
     *              color RED (see RFC 2697 and RFC 2698 for the
     *              meaning of these colors).  When index is out of
     *              range, the final value of result is not specified,
     *              and should be ignored by the caller.
     */
#if V1MODEL_VERSION >= 20200408
    void execute_meter<T>(in I index, out T result);
#else
    void execute_meter<T>(in bit<32> index, out T result);
#endif
}

extern direct_meter<T> {
    /***
     * A direct_meter object is created by calling its constructor.
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).  After constructing the
     * object, you can associate it with at most one table, by adding
     * the following table property to the definition of that table:
     *
     *     meters = <object_name>;
     */
    direct_meter(MeterType type);
    /***
     * After a direct_meter object has been associated with a table as
     * described in the documentation for the direct_meter
     * constructor, every time the table is applied and a table entry
     * is matched, the meter state associated with the matching entry
     * is read, modified, and written back, atomically relative to the
     * processing of other packets, regardless of whether the read()
     * method is called in the body of that action.
     *
     * read() may only be called within an action executed as a result
     * of matching a table entry, of a table that has a direct_meter
     * associated with it.  Calling read() causes an integer encoding
     * of one of the colors green, yellow, or red to be written to the
     * result out parameter.
     *
     * @param result Type T must be bit<W> with W >= 2.  The value of
     *              result will be assigned 0 for color GREEN, 1 for
     *              color YELLOW, and 2 for color RED (see RFC 2697
     *              and RFC 2698 for the meaning of these colors).
     */
    void read(out T result);
}
```

## 关于P4交换机的知识
***交换机类型***

- **`BMv2`**: 这是一个常用的P4软件交换机。它的GitHub页面提供了简单的CLI和gRPC API以及Thrift API的文档。BMv2（Behavioral Model version 2）是一个软件模拟的 P4 可编程交换机，常用于 P4 学习和开发调试。
simple_switch_CLI和bmv2（behavioral model v2）是紧密相关的工具，用于开发和测试基于P4语言的可编程数据平面。
bmv2是一个开源的P4软件交换机模拟器，它实现了P4语言规范，并提供了一个运行时环境来加载和执行P4程序。bmv2模拟器可以在常规的计算机上模拟多个交换机实例，使开发人员能够在实验室环境中测试和验证自定义的数据包处理逻辑。
simple_switch_CLI是与bmv2交互的命令行界面。它提供了一组命令和工具，用于与运行在bmv2模拟器上的simple_switch实例进行交互。通过simple_switch_CLI，开发人员可以加载P4程序、配置表项、查看和修改运行时状态、监控计数器等。
简而言之，bmv2是P4软件交换机模拟器，而simple_switch_CLI是与bmv2交互的命令行界面。它们一起提供了一个完整的开发和测试环境，用于实现和验证基于P4的可编程数据平面。

- **`P4Runtime`**: 这是一个为控制P4设备而设计的标准API。它的主要文档在P4官方网站上。
- **`ONOS`** (Open Network Operating System): ONOS提供了一种P4Runtime的实现，也有自己的API和规则。ONOS的文档位于其官方Git仓库或者官方网站。NOS 是一个开源的网络操作系统，它支持 SDN (软件定义网络) 控制器的多种功能，其中就包括 Meter 管理。
- 还有其他一些供应商特定的P4交换机和控制平面API，如Cisco，Juniper等。

***查看自己linux系统编译P4程序时使用的命令行工具或集成开发环境（IDE）***
- **使用--version或-v查看工具版本**:对于许多命令行工具来说，你通常可以通过在命令后添加--version或-v选项来查看软件版本。例如，对于p4c（P4编译器的一个常见实现），你可以这样做：
```bash
   p4c --version
```
- **检查IDE的关于信息**:对于IDE，你通常可以在其图形界面中找到一个关于（About）或者帮助（Help）的菜单选项，里面会显示版本信息和其他相关数据。
使用which定位程序路径:如果你不确定工具的执行文件存放在何处或者使用的是什么版本，你可以使用which命令来定位它。
```bash
   which p4c
```
- **查看安装的包信息**:对于使用包管理器安装的软件，如apt或yum，你可以查询包管理器以获取工具的信息。
    - 在Debian或Ubuntu系统上使用apt：
```bash
   apt list --installed | grep p4c
```
    - 在Fedora, CentOS或RHEL上使用yum或dnf：
```bash
   dnf list installed | grep p4c
```
- **使用文件查找命令**:如果你不知道程序的确切名称，你可以使用find或locate命令在系统上搜索。
```bash
   find / -name p4c
```
- **检查环境设置**:某些IDE或工具可能会在你的shell环境配置中设置环境变量，如.bashrc或.profile文件。你可以检查这些文件来找到有关的设置。
```bash
   cat ~/.bashrc | grep P4
```
- **查看历史命令**:如果你之前曾经在shell中调用过这个工具，那么你可以使用history命令来检索之前输入过的命令。
```bash
   history | grep p4c
```

## 实体机运行P4报错
**在/P4/tutorials/exercises/basic运行make报错缺少mininet module，具体报错信息如下：**

```bash
sinet@sinet161:~/p4/tutorials/exercises/basic$ make clean
sudo mn -c
Traceback (most recent call last):
  File "/usr/local/bin/mn", line 28, in <module>
    from mininet.clean import cleanup
ModuleNotFoundError: No module named 'mininet'
make: *** [../../utils/Makefile:38: stop] Error 1

```

### 1. python版本不对
**找到一个可以正确运行的服务器，输入python，查看其版本为3.8，而出错机器显示的版本号为3.10，或是python不显示但运行python3可以查看，两个情况报错显示如下：**
```bash
sinet@sinet161:~/p4/tutorials/exercises/basic$ python
Python 3.10.13 (main, Aug 25 2023, 13:20:03) [GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import mininet
>>> 
```
```bash
python
-bash: python: command not found
```
解决办法，使用软连接符号修改默认符号链接。将 python 符号链接指向 python3.8 可执行文件。这样，无需创建别名，直接运行 python 命令即可执行 Python 3.8。
注意：修改默认符号链接需要管理员权限，因此需要使用 sudo 命令。
```bash
sudo ln -sf /usr/bin/python3.8 /usr/bin/python
```
这将把 /usr/bin/python 符号链接指向 /usr/bin/python3.8 可执行文件。请根据你的系统和 Python 3.8 安装路径进行相应的更改。

- ln -sf 会强制删除已存在的链接并创建新的链接，而无需手动删除旧链接。
- ln -s 会在目标链接已存在时失败，需要手动删除旧链接后再创建新的链接。
### 2.python版本正确但是依旧报错
进入python，导入模块，如果没有就使用pip安装，有的话查看其位置
```bash
sinet@sinet161:~/p4/tutorials/exercises/basic$ python
Python 3.8.10 (default, May 26 2023, 14:05:08) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import p4
>>> print(p4.__file__)
/usr/local/lib/python3.8/dist-packages/p4/__init__.py
>>> 
```

查看位置后，运行正确机器的P4，根据报错信息打印出其P4文件位置（比如下面示例是在"/home/sinet/P4/tutorials/utils/p4runtime_lib/simple_controller.py"打印，将能用机器的P4文件直接替换掉
```bash
Traceback (most recent call last):
  File "/home/sinet/P4/tutorials/exercises/basic/../../utils/run_exercise.py", line 28, in <module>
    import p4runtime_lib.simple_controller
  File "/home/sinet/P4/tutorials/utils/p4runtime_lib/simple_controller.py", line 22, in <module>
    from p4.config.v1 import p4info_pb2
ModuleNotFoundError: No module named 'p4'
```


期间发生了使用符号链接之后运行python还是无显示的状况，可以通过命令查看当前符号指向，发现确实没有被修改，因此先把原来的删除，然后再添加，发现可以了
```bash
sinet@sinet165:~$ ls -l /usr/bin/python
lrwxrwxrwx 1 root root 24 3月  29 15:21 /usr/bin/python -> /usr/local/lib/python3.8
#发现还是错的
sinet@sinet165:~$ sudo ln -sf /usr/bin/python3.8 /usr/bin/python
[sudo] password for sinet: 
#重新运行发现依旧错误
sinet@sinet165:~$ ls -l /usr/bin/python
lrwxrwxrwx 1 root root 24 3月  29 15:21 /usr/bin/python -> /usr/local/lib/python3.8
#将原有的删掉
sinet@sinet165:~$ sudo rm /usr/bin/python
#查看发现果然删了
sinet@sinet165:~$ ls -l /usr/bin/python
ls: cannot access '/usr/bin/python': No such file or directory
#再次修改
sinet@sinet165:~$ sudo ln -sf /usr/bin/python3.8 /usr/bin/python
#查看发现修改成功
sinet@sinet165:~$ ls -l /usr/bin/python
lrwxrwxrwx 1 root root 18 3月  29 15:42 /usr/bin/python -> /usr/bin/python3.8
#运行python输出正确
sinet@sinet165:~$ python
Python 3.8.10 (default, Nov 22 2023, 10:22:35) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
```
### 3.替换之后依旧报错
在不删除原有p4模块的情况下，使用pip install p4报错了
报错信息如下：
```bash
sinet@sinet165:~/P4/tutorials/exercises/basic$ pip install p4
Traceback (most recent call last):
  File "/usr/bin/pip", line 11, in <module>
    load_entry_point('pip==20.0.2', 'console_scripts', 'pip')()
  File "/usr/lib/python3/dist-packages/pip/_internal/cli/main.py", line 73, in main
    command = create_command(cmd_name, isolated=("--isolated" in cmd_args))
  File "/usr/lib/python3/dist-packages/pip/_internal/commands/__init__.py", line 96, in create_command
    module = importlib.import_module(module_path)
  File "/usr/lib/python3.10/importlib/__init__.py", line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File "<frozen importlib._bootstrap>", line 1050, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1027, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1006, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 688, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 883, in exec_module
  File "<frozen importlib._bootstrap>", line 241, in _call_with_frames_removed
  File "/usr/lib/python3/dist-packages/pip/_internal/commands/install.py", line 24, in <module>
    from pip._internal.cli.req_command import RequirementCommand
  File "/usr/lib/python3/dist-packages/pip/_internal/cli/req_command.py", line 15, in <module>
    from pip._internal.index.package_finder import PackageFinder
  File "/usr/lib/python3/dist-packages/pip/_internal/index/package_finder.py", line 21, in <module>
    from pip._internal.index.collector import parse_links
  File "/usr/lib/python3/dist-packages/pip/_internal/index/collector.py", line 12, in <module>
    from pip._vendor import html5lib, requests
ImportError: cannot import name 'html5lib' from 'pip._vendor' (/usr/lib/python3/dist-packages/pip/_vendor/__init__.py)
```
推测是pip版本问题，检查发现其使用的果然是python3.10版本
再做一个软连接把python3也链接过去
```bash
sudo ln -sf /usr/bin/python3.8 /usr/bin/python3
```
综上为了保证运行P4，我们做的软连接指向/usr/bin里面的Python要在最前面，反正就是保证安装p4的Python环境和使用的环境是一个

## P4-util学习
- github网址：https://github.com/nsg-ethz/p4-utils
```bash
git clone https://github.com/nsg-ethz/p4-utils.git
cd p4-utils
sudo ./install.sh
```

```bash
sinet@sinet165:~/P4/tutorials/exercises/cwnd_fairness_duibi/p4-utils$ sudo ./install.sh
[sudo] password for sinet: 
Obtaining file:///home/sinet/P4/tutorials/exercises/cwnd_fairness_duibi/p4-utils
Requirement already satisfied: googleapis-common-protos>=1.52 in /usr/local/lib/python3.8/dist-packages (from p4utils==0.2) (1.62.0)
Collecting grpcio==1.44.0
  Downloading grpcio-1.44.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (4.3 MB)
     |████████████████████████████████| 4.3 MB 257 kB/s 
Collecting ipaddr
  Downloading ipaddr-2.2.0.tar.gz (26 kB)
Collecting ipaddress
  Downloading ipaddress-1.0.23-py2.py3-none-any.whl (18 kB)
Collecting networkx
  Downloading networkx-3.1-py3-none-any.whl (2.1 MB)
     |████████████████████████████████| 2.1 MB 98 kB/s 
Requirement already satisfied: p4runtime in /usr/local/lib/python3.8/dist-packages (from p4utils==0.2) (1.3.0)
Collecting protobuf==3.20.3
  Downloading protobuf-3.20.3-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.whl (1.0 MB)
     |████████████████████████████████| 1.0 MB 249 kB/s 
Requirement already satisfied: psutil in /usr/local/lib/python3.8/dist-packages (from p4utils==0.2) (5.9.7)
Requirement already satisfied: scapy>=2.5.0 in /usr/local/lib/python3.8/dist-packages (from p4utils==0.2) (2.5.0)
Requirement already satisfied: setuptools in /usr/lib/python3/dist-packages (from p4utils==0.2) (45.2.0)
Requirement already satisfied: six>=1.5.2 in /usr/lib/python3/dist-packages (from grpcio==1.44.0->p4utils==0.2) (1.14.0)
Building wheels for collected packages: ipaddr
  Building wheel for ipaddr (setup.py) ... done
  Created wheel for ipaddr: filename=ipaddr-2.2.0-py3-none-any.whl size=18280 sha256=7d2e654f84477d0e9519f5d115fea5d17e681012259bed1fa344b0e229039680
  Stored in directory: /root/.cache/pip/wheels/38/59/0e/c20fbbd7969a095fa10b79bdde5d9852227f60bdbdd3a90b49
Successfully built ipaddr
Installing collected packages: grpcio, ipaddr, ipaddress, networkx, protobuf, p4utils
  Attempting uninstall: grpcio
    Found existing installation: grpcio 1.43.2
    Uninstalling grpcio-1.43.2:
      Successfully uninstalled grpcio-1.43.2
  Attempting uninstall: protobuf
    Found existing installation: protobuf 3.18.1
    Uninstalling protobuf-3.18.1:
      Successfully uninstalled protobuf-3.18.1
  Running setup.py develop for p4utils
Successfully installed grpcio-1.44.0 ipaddr-2.2.0 ipaddress-1.0.23 networkx-3.1 p4utils protobuf-3.20.3
Adding /usr/local/lib/python3.8/site-packages to Python3 path...
Done!
```